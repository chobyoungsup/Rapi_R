using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Net.NetworkInformation;
using System.IO;
using System.Threading;
using QuickChargeConfig;
using AVRIO;

namespace CSOS
{

    //0x01, // 충전기제어
    //0x02, // 충전단가 전달
    //0x03, // 누적전력량 요청
    //0x04, // 상태요청
    //0x05, // 시각동기
    //0x06, // 충전종료 알림 이력 요청
    
    public enum SNORECVCMD { ctrl = 0x01, unitprice, watt, status, timesync, endlog };

    //0x81, // 통신 시작전 버전확인
    //0x82, // 통신 시작 인증
    //0x83, // 통신 상태 확인
    //0x84, // 충전기 종료
    //0x85, // 시각동기 요청
    //0x86, // 충전단가 요청
    //0x87, // 회원정보확인 요청
    //0x88, // 충전시작 알림
    //0x89, // 충전종료 알림

    public enum SNOSENDCMD { ver = 0x81, confirm, pingpong, terminate, timesync, unitpricereq, member, charge_start, charge_end };

    public enum SNOCMD
    {
        none = 0x00,
        r_ctrl = 0x01, r_unitprice, r_watt, r_status, r_timesync, r_endlog,
        s_ver = 0x81, s_confirm, s_pingpong, s_terminate, s_timesync, s_unitpricereq, s_member, s_charge_start, s_charge_end
    };

    public class SNOHeaderInfo
    {
        private bool crc;

        public bool Crc
        {
            get { return crc; }
            set { crc = value; }
        }
        private byte cmd;

        public byte Cmd
        {
            get { return cmd; }
            set { cmd = value; }
        }
        private byte seq;

        public byte Seq
        {
            get { return seq; }
            set { seq = value; }
        }
        private byte ctrl;

        public byte Ctrl
        {
            get { return ctrl; }
            set { ctrl = value; }
        }
        private byte ack;

        public byte Ack
        {
            get { return ack; }
            set { ack = value; }
        }
        public byte[] byDateTime;

        public SNOHeaderInfo()
        {
            byDateTime = new byte[8];
        }
    }

    /// <summary>
    /// 세니온서버
    /// </summary>
    public class SNONet
    {
        byte byStart = 0x7E;
        byte[] byVer = new byte[4];
        byte[] byAuthKey = new byte[16];
        int nHeaderSize = 20;
        bool isPolling = false;

        uint remindCurrentBase = 0;
        int currentHour = 0;
        int currentHourPrev = 0;
        int currentMin = 0;
        int currentMinPrev = 0;
        int currentPollCount = -1;
        int currentChangeHour = -1;

        uint[,] RemindCurrentTableToday = new uint[24, 4];
        uint[,] RemindCurrentTableYesterday = new uint[24, 4];
        uint[,] RemindCurrentCharging = new uint[24, 4];

        private Socket serverSock = null;
        private Socket clientSock = null;

        TcpClient server = new TcpClient();
        NetworkStream ns;

        Thread recvThread;

        byte[] byACK = new byte[] { (byte)'r', (byte)'y', (byte)'e', (byte)'n' };
        enum CTRL { start = 0, cont, end, single };

        IPAddress myip;

        private SNOCMD sendCmd = 0;
        private SNOCMD recvCmd = 0;

        public SNOCMD SendCmd
        {
            get { return sendCmd; }
            set { sendCmd = value; }
        }
        public SNOCMD RecvCmd
        {
            get { return recvCmd; }
            set { recvCmd = value; }
        }

        byte byReadSeq = 0;
        byte byReadCtrl = 0;
        byte byReadACK = 0;
        byte byReadCmd = 0;
        byte[] byReadDateTime = new byte[8];

        //static byte[] byAuth;
        private ushort cpid = 1;

        public ushort Cpid
        {
            get { return cpid; }
            set { cpid = value; }
        }

        ushort CSOSid = 65534;
        ushort CRC16;

        // 시간정보
        byte[] byDateTime = new byte[8];

        byte[] byChargePriceDateTime = new byte[8];
        ushort[] uChargePriceHourData = new ushort[24];

        public SNONet()
        {
            sendCmd = SNOCMD.none;
            recvCmd = SNOCMD.none;
            ConfigInit();
            AVRIO.avrio.SendCSOSOrder += new CSOSOrderEvent(avrio_SendCSOSOrder);
        }

        void avrio_SendCSOSOrder(CSOSCMD command, params object[] list)
        {
            SendCSOSCommand(command);
        }

        public void ConfigInit()
        {
            IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
            myip = host.AddressList[0];

            //csos.Serverip = ChargeConfig.GetConfig("CSOS", "IP", "61.106.146.207");
            csos.Serverip = ChargeConfig.GetConfig("CSOS", "IP", "192.168.1.249");
            
            csos.Serverport = Convert.ToInt32(ChargeConfig.GetConfig("CSOS", "Port", "8200"));

            //version = csos.Version;
            CSOS.version ver = csos.GetVersion();
#if DEBUG
            SetVersion("0.6.0");
            csos.Cpid = 1;
            Cpid = 1;
#endif

            string value = ChargeConfig.GetConfig("CSOS", "AuthKey", "0123456789abcdef");
            csos.Authkey = value;

            byte[] key = Encoding.ASCII.GetBytes(csos.Authkey);
            for (int i = 0; i < byAuthKey.Length; i++)
            {
                if (i == key.Length) break;

                byAuthKey[i] = key[i];
            }

            remindCurrentBase = AVRIO.avrio.VaildWatt;
        }

        public bool Connect()
        {
            byte[] data = new byte[1024];

            try
            {
                IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
                myip = host.AddressList[0];
                csos.Ip = myip.ToString();

                // TEST IP : 61.106.146.207

                IPEndPoint ipep = new IPEndPoint(IPAddress.Parse(csos.Serverip), csos.Serverport);
                serverSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                //serverSock.ReceiveTimeout = 3000;
                serverSock.Blocking = true;
                serverSock.Connect(ipep);
                clientSock = serverSock;

            }
            catch (SocketException ex)
            {
                AVRIO.avrio.EventMsg = ex.Message;
                if (serverSock.Connected == true) serverSock.Close(); // 통신종료 리소스 해제
                return false;
            }

            return true;
        }

        public bool DoVersionCheck()
        {
            try
            {
                byte[] bySendBuffer = MakeSendVersionData();
                serverSock.Send(bySendBuffer);
                byte[] byReadBuffer = new byte[1024];
                int numberOfBytesRead = serverSock.Receive(byReadBuffer);
            }
            catch (Exception e)
            {
                AVRIO.avrio.EventMsg = e.Message;
            }

            return true;
        }

        #region Poll function
        public void PollFunction()
        {
            bool ret;

            //do
            //{
            //    Thread.Sleep(5000);     // 5 sec
            //    ret = Connect();
            //} while (!ret);

            //AVRIO.avrio.EventMsg = "[SNO] Connect OK";

            byte[] data = new byte[1024];

            do
            {
                try
                {
                    IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
                    myip = host.AddressList[0];
                    csos.Ip = myip.ToString();

                    // TEST IP : 61.106.146.207

                    IPEndPoint ipep = new IPEndPoint(IPAddress.Parse(csos.Serverip), csos.Serverport);
                    serverSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                    //serverSock.ReceiveTimeout = 3000;
                    serverSock.Blocking = true;
                    serverSock.Connect(ipep);
                    clientSock = serverSock;

                    Thread.Sleep(5000);
                }
                catch (Exception e)
                {
                    AVRIO.avrio.EventMsg = e.Message;
                    if (serverSock.Connected == true) serverSock.Close(); // 통신종료 리소스 해제
                    Thread.Sleep(5000);
                    continue;
                }
            } while (serverSock.Connected == false);

            recvThread = new Thread(RecvThreadRun);
            if (recvThread != null)
            {
                isPolling = true;

                recvThread.Start();

                Thread.Sleep(1000);
            }

            byte[] bySendBuffer = MakeSendVersionData();
            serverSock.Send(bySendBuffer);

            Thread.Sleep(100);

            byte[] bySendBuffer2 = MakeSendConfirmAuthKeyData();
            serverSock.Send(bySendBuffer2);

            Thread.Sleep(100);

            byte[] bySendBuffer3 = MakeSendUCostReq();
            serverSock.Send(bySendBuffer3);

            Thread.Sleep(100);

            try
            {
                while (true)
                {
                    DateTime dt = DateTime.Now;
                    string today = dt.ToString("yyyyMMdd");
                    currentHour = dt.Hour;
                    currentMin = dt.Minute;

                    if ((dt.Minute % 15) == 0)
                    {
                        if ((currentMin != currentMinPrev) || (currentHour != currentHourPrev))
                        {
                            currentHourPrev = currentHour;
                            currentMinPrev = currentMin;
                            if (currentHourPrev == 0 && currentMinPrev == 0)
                            {
                                Array.Copy(RemindCurrentTableToday, RemindCurrentTableYesterday, RemindCurrentTableToday.Length);
                                Array.Clear(RemindCurrentTableToday, 0, RemindCurrentTableToday.Length);
                            }

                        }
                    }

                    int tHour = currentHourPrev;
                    int iMin = (currentMinPrev == 0) ? 0 : ((currentMinPrev == 15) ? 1 : ((currentMinPrev == 30) ? 2 : 3));
                    RemindCurrentTableToday[tHour, iMin] = avrio.VaildWatt;

                    if (AVRIO.avrio.CurrentStatus == SysStatus.SysRun)
                    {
                        RemindCurrentCharging[tHour, iMin] = avrio.ChargeStartWattN - avrio.VaildWatt;
                    }
                    else
                    {
                        RemindCurrentCharging[tHour, iMin] = 0;
                    }

                    // 1분주기로 상태정보 전송
                    if (currentMin != currentPollCount)
                    {
                        currentPollCount = currentMin;

                        avrio.CsosCommand = CSOSCMD.ChargeCurrent;
                    }

                    // 매시간마다 단가적용변경
                    if (currentHour != currentChangeHour)
                    {
                        currentChangeHour = currentHour;

                        if (currentChangeHour == 0)
                        {
                            if (today == AVRIO.avrio.UnitPriceListNext.First().Date)
                            {
                                AVRIO.avrio.UnitPriceList.Clear();
                                // 다음날 단가적용
                                foreach (AVRIO.UnitPricePerTimes ut in AVRIO.avrio.UnitPriceListNext)
                                {
                                    AVRIO.avrio.UnitPriceList.Add(ut);
                                }
                            }
                        }

                        foreach (AVRIO.UnitPricePerTimes up in AVRIO.avrio.UnitPriceList)
                        {
                            if (up.Hour == currentHour)
                            {
                                AVRIO.avrio.CurrentUnitPrice = up.Ucost;
                                break;
                            }
                        }
                        //AVRIO.avrio.CurrentUnitPrice = AVRIO.avrio.UnitPriceList.Select();
                    }

                    Thread.Sleep(100);

                    if (serverSock.Connected == false)
                    {
                        try
                        {
                            IPEndPoint ipep2 = new IPEndPoint(IPAddress.Parse(csos.Serverip), csos.Serverport);
                            serverSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                            //serverSock.ReceiveTimeout = 3000;
                            serverSock.Blocking = true;
                            serverSock.Connect(ipep2);
                            clientSock = serverSock;
                        }
                        catch(Exception e)
                        {
                            System.Diagnostics.Debug.WriteLine(e.Message);
                            Thread.Sleep(100);
                            continue;
                        }

                        byte[] bySendBuffer4 = MakeSendVersionData();
                        serverSock.Send(bySendBuffer4);

                        Thread.Sleep(100);

                        byte[] bySendBuffer5 = MakeSendConfirmAuthKeyData();
                        serverSock.Send(bySendBuffer5);

                        Thread.Sleep(100);

                        byte[] bySendBuffer6 = MakeSendUCostReq();
                        serverSock.Send(bySendBuffer6);

                        Thread.Sleep(100);
                    }
                }
            }
            catch (SocketException ex)
            {
                AVRIO.avrio.EventMsg = ex.Message;
                if (serverSock.Connected == true) serverSock.Close(); // 통신종료 리소스 해제
            }

            //Thread mainThread = new Thread(new ThreadStart(RecvThreadRun));
            //mainThread.Start();

            //byte[] bySendBuffer = MakeSendVersionData();
            //serverSock.Send(bySendBuffer);

            ////ret = DoVersionCheck();

            ////AVRIO.avrio.EventMsg = "[SNO] VersionCheck OK";
            //while(serverSock.Connected)
            //{
            //}

            //AVRIO.avrio.EventMsg = "[SNO] Thread Terminate";
        }
        #endregion

        public void SendCSOSCommand(CSOSCMD cmd)
        {
            if (csos.Company == "KDN") return;
            if (serverSock == null) return;

            if (serverSock.Connected == false)
            {
                return;
            }

            lock (this)
            {

                Socket sock = clientSock;
                switch (cmd)
                {
                    // 차량인증
                    case CSOSCMD.CarCert:
                        break;
                    // 사용자인증
                    case CSOSCMD.MemberCert:
                        {
                            try
                            {
                                byte[] data = MakeSendMemberConfirm();
                                serverSock.Send(data);
                            }
                            catch (Exception e)
                            {
                                System.Diagnostics.Debug.WriteLine(e.Message);
                            }
                        }
                        break;
                    // 충전시작
                    case CSOSCMD.ChargeStart:
                        {
                            try
                            {
                                byte[] data = MakeSendChargeStart();
                                serverSock.Send(data);
                            }
                            catch (Exception e)
                            {
                                System.Diagnostics.Debug.WriteLine(e.Message);
                            }
                        }
                        break;
                    // 충전종료
                    case CSOSCMD.ChargeFinish:
                        {
                            try
                            {
                                byte[] data = MakeSendChargeFinish();
                                serverSock.Send(data);
                            }
                            catch (Exception e)
                            {
                                System.Diagnostics.Debug.WriteLine(e.Message);
                            }
                        }
                        break;
                    // 충전취소
                    case CSOSCMD.ChargeCancel:
                        break;
                    // 충전중 누적전력량
                    case CSOSCMD.ChargeUsePower:
                        {
                        }
                        break;
                    // 충전단가요청
                    case CSOSCMD.ChargeUnitCostReq:
                        {
                            try
                            {
                                byte[] data = MakeSendUCostReq();
                                //ns.Write(data, 0, data.Length);
                                //ns.Flush();
                                sock.Send(data);
                            }
                            catch (Exception e)
                            {
                                AVRIO.avrio.EventMsg = e.Message;
                            }
                        }
                        break;
                    // 충전기 제어
                    case CSOSCMD.DevCtrl:
                        {
                        }
                        break;
                    // 충전기 시작
                    case CSOSCMD.DevStart:
                        {
                            try
                            {
                                byte[] data = MakeSendConfirmAuthKeyData();
                                //ns.Write(data, 0, data.Length);
                                //ns.Flush();
                                sock.Send(data);
                            }
                            catch (Exception e)
                            {
                                AVRIO.avrio.EventMsg = e.Message;
                            }
                        }
                        break;
                    // 충전기 정지
                    case CSOSCMD.DevStop:
                        {
                        }
                        break;
                    // 시각동기화
                    case CSOSCMD.TimeSync:
                        {
                        }
                        break;
                    case CSOSCMD.TimeStamp:
                        {
                        }
                        break;
                    // 누적전력량
                    case CSOSCMD.ChargeCurrent:
                        {
                            try
                            {
                                byte[] data = MakeSendConnectionCheckData();
                                serverSock.Send(data);
                            }
                            catch (Exception e)
                            {
                                System.Diagnostics.Debug.WriteLine(e.Message);
                            }
                        }
                        break;
                }
            } // lock
        }

        public void RecvThreadRun()
        {
            AVRIO.avrio.EventMsg = "[SNO] Recv Thread Run";
            Socket sock = clientSock;

            while (sock != null)
            {
                try
                {
                    byte[] byReadBuffer = new byte[32767];
                    int numberOfBytesRead = sock.Receive(byReadBuffer, byReadBuffer.Length, 0); ;

                    if (numberOfBytesRead == 0)
                    {
                        continue;
                    }
                    byte[] byRead = new byte[numberOfBytesRead];
                    Array.Copy(byReadBuffer, byRead, numberOfBytesRead);
                    AVRIO.avrio.ReceiveServer = ByteArrayToHexString(byRead);

                    ParserReadBuffer(byRead);

                }
                catch (Exception e)
                {
                    System.Diagnostics.Debug.WriteLine("[SNO-RecvThread]" + e.Message);
                    Thread.Sleep(1000);
                    sock = clientSock;
                }

                if (isPolling == false)
                {
                    break;
                }
            }
        }

        public void ParserReadBuffer(byte[] _byBuffer)
        {
            SNOHeaderInfo hInfo = new SNOHeaderInfo();

            lock (this)
            {

                ushort uReadLen = ReadHeader(_byBuffer, ref hInfo);
                bool bCheck = CRCCheck(_byBuffer);
                byte byCmd = GetReadCmd();
                byte bySeq = GetReadSeq();
                byte byCtrl = GetReadCtrl();
                byte byACK = GetReadACK();
                byte[] byReadDateTime = GetReadDateTime();
#if DEBUG
                if (hInfo.Cmd != (byte)SNORECVCMD.status)
                {

                    StringBuilder myDateTimeMsg = new StringBuilder();
                    myDateTimeMsg.AppendFormat("[SNO]Recv DateTime : {0}/{1}/{2} {3}:{4}:{5}.{6}", (int)(byReadDateTime[0] + 2000), (int)byReadDateTime[1], (int)byReadDateTime[2],
                                            (int)byReadDateTime[3], (int)byReadDateTime[4], (int)byReadDateTime[5], (int)byReadDateTime[6]);

                    AVRIO.avrio.EventMsg = myDateTimeMsg.ToString();

                    StringBuilder myCompleteMessage = new StringBuilder();
                    myCompleteMessage.AppendFormat("[SNO]ACK : {0}, CMD: {1}, CTRL: {2}, COUNT: {3}, CRC : {4}", ((char)byACK).ToString(), ((int)hInfo.Cmd).ToString("X"), (int)byCtrl, uReadLen, bCheck);

                    AVRIO.avrio.EventMsg = myCompleteMessage.ToString();
                }
#endif

                switch (hInfo.Cmd)
                {
                    case (byte)SNOSENDCMD.ver:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            AVRIO.avrio.EventMsg = ((SNOCMD)hInfo.Cmd).ToString() + "] 응답결과:" + (char)byData[0];
                        }
                        break;
                    case (byte)SNOSENDCMD.timesync:
                    case (byte)SNOSENDCMD.pingpong:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            AVRIO.avrio.EventMsg = ((SNOCMD)hInfo.Cmd).ToString() + "] 응답결과:" + (char)byData[0];
                        }
                        break;
                    case (byte)SNOSENDCMD.confirm:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            AVRIO.avrio.EventMsg = ((SNOCMD)hInfo.Cmd).ToString() + "] 응답결과:" + (char)byData[0];
                        }
                        break;
                    case (byte)SNOSENDCMD.member:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            AVRIO.avrio.EventMsg = ((SNOCMD)hInfo.Cmd).ToString() + "] 응답결과:" + (char)byData[0];
                        }
                        break;
                    case (byte)SNOSENDCMD.charge_start:
                    case (byte)SNOSENDCMD.charge_end:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            AVRIO.avrio.EventMsg = ((SNOCMD)hInfo.Cmd).ToString() + "] 응답결과:" + (char)byData[0];
                        }
                        break;
                    case (byte)SNOSENDCMD.unitpricereq:
                        {
                            byte[] byPriceData = ReadData(_byBuffer, uReadLen);
                            ushort[] uPriceData = ReadPriceData(byPriceData);
                            byte[] byChargeDateTime = GetChargePriceDateTime();

                            StringBuilder myMessage = new StringBuilder();
                            myMessage.AppendFormat("{0}-{1}-{2} {3}:{4}:{5}.{6}", (int)(byPriceData[0] + 2000), (int)byPriceData[1], (int)byPriceData[2],
                                                    (int)byPriceData[3], (int)byPriceData[4], (int)byPriceData[5], (int)byPriceData[6]);

                            AVRIO.avrio.PriceMsg = "Clear";
                            AVRIO.avrio.PriceMsg = "단가적용일시 " + myMessage.ToString();

                            string today = DateTime.Now.ToString("yyyyMMdd");
                            string d = ((int)(byPriceData[0] + 2000)).ToString() + ((int)byPriceData[1]).ToString("00") + ((int)byPriceData[2]).ToString("00");

                            AVRIO.avrio.UnitPriceList.Clear();
                            for (int i = 0; i < uPriceData.Length; i++)
                            {
                                AVRIO.avrio.UnitPriceList.Add(new UnitPricePerTimes(i, 0, (double)((double)uPriceData[i] / (double)10), today));
                                AVRIO.avrio.PriceMsg = "[" + i + "]" + (double)((double)uPriceData[i] / (double)10);
                                if (DateTime.Now.Hour == i)
                                {
                                    AVRIO.avrio.CurrentUnitPrice = (double)((double)uPriceData[i] / (double)10);
                                }
                            }

                            if (hInfo.Cmd == (byte)SNORECVCMD.unitprice)
                            {
                                byte[] sendData = MakeResponseUnitPrice(byPriceData);
                                serverSock.Send(sendData);
                            }
                        }
                        break;
                    case (byte)SNORECVCMD.unitprice:
                        {
                            byte[] byPriceData = ReadData(_byBuffer, uReadLen);
                            ushort[] uPriceData = ReadPriceData(byPriceData);
                            byte[] byChargeDateTime = GetChargePriceDateTime();

                            StringBuilder myMessage = new StringBuilder();
                            myMessage.AppendFormat("{0}-{1}-{2} {3}:{4}:{5}.{6}", (int)(byPriceData[0] + 2000), (int)byPriceData[1], (int)byPriceData[2],
                                                    (int)byPriceData[3], (int)byPriceData[4], (int)byPriceData[5], (int)byPriceData[6]);

                            string today = DateTime.Now.ToString("yyyyMMdd");
                            string d = ((int)(byPriceData[0] + 2000)).ToString() + ((int)byPriceData[1]).ToString("00") + ((int)byPriceData[2]).ToString("00");

                            AVRIO.avrio.PriceMsg = "Clear";
                            AVRIO.avrio.PriceMsg = "단가적용일시 " + myMessage.ToString();

                            AVRIO.avrio.UnitPriceListNext.Clear();
                            for (int i = 0; i < uPriceData.Length; i++)
                            {
                                AVRIO.avrio.UnitPriceListNext.Add(new UnitPricePerTimes(i, 0, (double)((double)uPriceData[i] / (double)10), d));
                                AVRIO.avrio.PriceMsg = "[" + i + "]" + (double)((double)uPriceData[i] / (double)10);
                                if (DateTime.Now.Hour == i && d == today)
                                {
                                    AVRIO.avrio.CurrentUnitPrice = (double)((double)uPriceData[i] / (double)10);
                                }
                            }

                            QuickChargeConfig.ChargeConfig.SetUnitPrice();
                            
                            if (hInfo.Cmd == (byte)SNORECVCMD.unitprice)
                            {
                                byte[] sendData = MakeResponseUnitPrice(byPriceData);
                                serverSock.Send(sendData);
                            }
                        }
                        break;
                    case (byte)SNORECVCMD.ctrl:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            byte[] sendData = MakeResponseControl(byData);
                            serverSock.Send(sendData);
                        }
                        break;
                    case (byte)SNORECVCMD.watt:
                        {
                            byte[] byData = ReadData(_byBuffer, uReadLen);
                            byte[] sendData = MakeResponseCurrent(byData);
                            serverSock.Send(sendData);
                        }
                        break;
                    case (byte)SNORECVCMD.status:
                        {
                            byte[] _bySendBuffer = MakeResponseCurrentStatus();
                            serverSock.Send(_bySendBuffer);
                        }
                        break;
                    default:
                        {
                            AVRIO.avrio.EventMsg = "[SNO] (" + hInfo.Cmd.ToString("X") + ") 알수없는 데이터 수신";
                        }
                        break;
                }
            }
        }

        public void SetCPID(ushort nId)
        {
            cpid = nId;
        }

        public void SetVersion(String str)
        {
            String[] tmp = str.Split('.');

            byVer[0] = Convert.ToByte(tmp[0]);
            byVer[1] = Convert.ToByte(tmp[1]);
            byVer[2] = Convert.ToByte(tmp[2]);
            byVer[3] = 0;
        }

        public void Setversion(byte[] _byVer)
        {
            for (int i = 0; i < _byVer.Length; i++)
            {
                if (i == byVer.Length) return;
                byVer[i] = _byVer[i];
            }
        }

        public void SetVersion(byte Service, byte Major, byte Minor)
        {
            byVer[0] = Service;
            byVer[1] = Major;
            byVer[2] = Minor;
            byVer[3] = 0;
        }

        public void SetAuthKey(String str)
        {
            char[] chTmp = str.ToCharArray();
            for (int i = 0; i < chTmp.Length; i++)
            {
                if (i == byAuthKey.Length) return;
                byAuthKey[i] = (byte)chTmp[i];
            }
        }

        public byte GetReadCmd()
        {
            return byReadCmd;
        }

        public byte GetReadSeq()
        {
            return byReadSeq;
        }

        public byte GetReadACK()
        {
            return byReadACK;
        }

        public byte GetReadCtrl()
        {
            return byReadCtrl;
        }

        public byte[] GetReadDateTime()
        {
            return byReadDateTime;
        }

        public byte[] GetChargePriceDateTime()
        {
            return byChargePriceDateTime;
        }

        public ushort ReadHeader(byte[] _byBuffer, ref SNOHeaderInfo hInfo)
        {
            ushort uLen;

            if (_byBuffer[0] != byStart)
            {
                return 0;
            }
            byte byCmd = _byBuffer[1];
            byReadCmd = byCmd;

            hInfo.Cmd = byCmd;

#if BIGENDIAN
            uLen = _byBuffer[2];
            uLen <<= 4;
            uLen += _byBuffer[3];
#else
            uLen = _byBuffer[3];
            uLen <<= 4;
            uLen += _byBuffer[2];
#endif
            byReadSeq = _byBuffer[4];
            byReadACK = _byBuffer[5];

            byReadCtrl = _byBuffer[6];

            hInfo.Seq = _byBuffer[4];
            hInfo.Ack = _byBuffer[5];
            hInfo.Ctrl = _byBuffer[6];

            ushort SRCid;
            ushort DSTid;

#if BIGENDIAN
            SRCid = _byBuffer[8];
            SRCid <<= 4;
            SRCid += _byBuffer[9];
            DSTid = _byBuffer[10];
            DSTid <<= 4;
            DSTid += _byBuffer[11];
#else
            SRCid = _byBuffer[9];
            SRCid <<= 4;
            SRCid += _byBuffer[8];
            DSTid = _byBuffer[11];
            DSTid <<= 4;
            DSTid += _byBuffer[10];
#endif

            // DateTime
            for (int i = 0; i < 8; i++)
            {
                byReadDateTime[i] = _byBuffer[12 + i];
                hInfo.byDateTime[i] = _byBuffer[12 + i];
            }

            return uLen;
        }

        public ushort ReadHeader(byte[] _byBuffer)
        {
            ushort uLen;

            if (_byBuffer[0] != byStart)
            {
                return 0;
            }
            byReadCmd = _byBuffer[1];

#if BIGENDIAN
            uLen = _byBuffer[2];
            uLen <<= 8;
            uLen += _byBuffer[3];
#else
            uLen = _byBuffer[3];
            uLen <<= 8;
            uLen += _byBuffer[2];
#endif
            byReadSeq = _byBuffer[4];
            byReadACK = _byBuffer[5];

            byReadCtrl = _byBuffer[6];

            ushort SRCid;
            ushort DSTid;

#if BIGENDIAN
            SRCid = _byBuffer[8];
            SRCid <<= 8;
            SRCid += _byBuffer[9];
            DSTid = _byBuffer[10];
            DSTid <<= 8;
            DSTid += _byBuffer[11];
#else
            SRCid = _byBuffer[9];
            SRCid <<= 8;
            SRCid += _byBuffer[8];
            DSTid = _byBuffer[11];
            DSTid <<= 8;
            DSTid += _byBuffer[10];
#endif

            // DateTime
            for (int i = 0; i < 8; i++)
            {
                byReadDateTime[i] = _byBuffer[12 + i];
            }

            return uLen;
        }

        public bool CRCCheck(byte[] _byBuffer)
        {
            uint uiCRC = 0;
            uint uiCOMP = 0;
            CRCCalculator cc = new CRCCalculator();

            uiCRC = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

            uiCOMP = _byBuffer[_byBuffer.Length - 2];
            uiCOMP <<= 8;
            uiCOMP += (uint)_byBuffer[_byBuffer.Length - 1];

            if (uiCRC == uiCOMP) return true;
            else return false;
        }

        public byte[] ReadData(byte[] _byBuffer, ushort uLen)
        {
            byte[] byData = new byte[uLen - nHeaderSize - 2];

            for (int i = 0; i < byData.Length; i++)
            {
                byData[i] = _byBuffer[nHeaderSize + i];
            }

            return byData;
        }

        /// <summary>
        /// 헤더생성
        /// </summary>
        /// <param name="_byBuffer">헤더삽입 버퍼 (헤더크기:20바이트)</param>
        /// <param name="cmd">명령구분</param>
        /// <param name="len">데이터길이(헤더+데이터+CRC)</param>
        /// <param name="seq">0~255반복</param>
        /// <param name="ctrl">시작:0, 중간:1, 끝:2, 단일프레임:3</param>
        public byte[] MakeHeader(byte cmd, ushort len, byte seq, byte ctrl)
        {
            DateTime dt = DateTime.Now;
            byte[] _byBuffer = new byte[nHeaderSize];

            _byBuffer[0] = byStart;
            _byBuffer[1] = cmd;
#if BIGENDIAN
            _byBuffer[2] = (byte)((len & 0xFF00) >> 4);
            _byBuffer[3] = (byte)(len & 0xFF);
#else
            _byBuffer[3] = (byte)((len & 0xFF00) >> 8);
            _byBuffer[2] = (byte)(len & 0xFF);
#endif
            _byBuffer[4] = seq;
            _byBuffer[5] = byACK[0];
            _byBuffer[6] = ctrl;
            _byBuffer[7] = 0;                               // reserved
#if BIGENDIAN
            _byBuffer[8] = (byte)((cpid & 0xFF00) >> 4);
            _byBuffer[9] = (byte)(cpid & 0xFF);
            _byBuffer[10] = (byte)((CSOSid & 0xFF00) >> 4);
            _byBuffer[11] = (byte)(CSOSid & 0xFF);
#else
            _byBuffer[9] = (byte)((cpid & 0xFF00) >> 8);
            _byBuffer[8] = (byte)(cpid & 0xFF);
            _byBuffer[11] = (byte)((CSOSid & 0xFF00) >> 8);
            _byBuffer[10] = (byte)(CSOSid & 0xFF);
#endif

            // DateTime
            _byBuffer[12] = (byte)(dt.Year % 100);
            _byBuffer[13] = (byte)(dt.Month);
            _byBuffer[14] = (byte)(dt.Day);
            _byBuffer[15] = (byte)(dt.Hour);
            _byBuffer[16] = (byte)(dt.Minute);
            _byBuffer[17] = (byte)(dt.Second);
            _byBuffer[18] = 0;
            _byBuffer[19] = 0;

            return _byBuffer;
        }

        public ushort[] ReadPriceData(byte[] _byBuffer)
        {
            int i = 0;

            for (i = 0; i < byChargePriceDateTime.Length; i++)
            {
                byChargePriceDateTime[i] = _byBuffer[i];
            }

            for (int j = 0; j < uChargePriceHourData.Length; j++)
            {
                uChargePriceHourData[j] = (ushort)((_byBuffer[i + 1] << 8) + _byBuffer[i]);
                i += 2;
            }

            return uChargePriceHourData;
        }

        public byte[] MakeSendVersionData()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 4 + 2]; // 22 + 4
            byte byCmd = (byte)SNOSENDCMD.ver;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            foreach (byte byBuf in byHeader)
            {
                _byBuffer[i++] = byBuf;
            }

            for (i = 0; i < byVer.Length; i++)
            {
                _byBuffer[nHeaderSize + i] = byVer[i];
            }

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeSendConfirmAuthKeyData()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 16 + 2]; // 22 + 16
            byte byCmd = (byte)SNOSENDCMD.confirm;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            foreach (byte byBuf in byHeader)
            {
                _byBuffer[i++] = byBuf;
            }

            for (i = 0; i < byAuthKey.Length; i++)
            {
                _byBuffer[nHeaderSize + i] = byAuthKey[i];
            }

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeSendConnectionCheckData()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 8 + 2]; // 22
            byte byCmd = (byte)SNOSENDCMD.pingpong;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            foreach (byte byBuf in byHeader)
            {
                _byBuffer[i++] = byBuf;
            }


            byte[] temp;
            uint cur = 0;

            int tHour = currentHourPrev;
            int iMin = (currentMinPrev + 3) % 4;
            if (iMin == 3)
            {
                tHour -= 1;
                tHour = ((tHour < 0) ? 23 : tHour);
            }
            if ((tHour == 23) && (iMin == 3))
            {
                cur = RemindCurrentTableYesterday[tHour, iMin];
            }
            else
            {
                cur = RemindCurrentTableToday[tHour, iMin];
            }
            temp = BitConverter.GetBytes(cur);
#if DEBUG
            if (cur == 0)
            {
                temp = BitConverter.GetBytes((uint)1234);
            }
#endif

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);
            i += temp.Length;

            temp = BitConverter.GetBytes(RemindCurrentCharging[tHour, iMin]);

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);
            i += temp.Length;

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeSendTerminateData()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 2]; // 22
            byte byCmd = (byte)SNOSENDCMD.terminate;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            foreach (byte byBuf in byHeader)
            {
                _byBuffer[i++] = byBuf;
            }

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);
            _byBuffer[_byBuffer.Length - 2] = (byte)((parity & 0xFF00) >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);

            return _byBuffer;
        }

        public byte[] MakeSendUCostReq()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 2]; // 22
            byte byCmd = (byte)SNOSENDCMD.unitpricereq;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeSendMemberConfirm()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 16 + 2]; // 22
            byte byCmd = (byte)SNOSENDCMD.member;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = nHeaderSize;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            byte[] temp = Encoding.ASCII.GetBytes(AVRIO.avrio.CardNo);

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);


            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeSendChargeStart()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 132 + 2]; // 22
            byte byCmd = (byte)SNOSENDCMD.charge_start;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            i = nHeaderSize;

            byte[] temp = GetStatusToByte();

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);

            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeSendChargeFinish()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 132 + 2]; // 22
            byte byCmd = (byte)SNOSENDCMD.charge_end;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            i = nHeaderSize;

            byte[] temp = GetStatusToByte();

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeResponseControl(byte[] data)
        {
            byte[] _byBuffer = new byte[nHeaderSize + data.Length + 2]; // 22
            byte byCmd = (byte)SNORECVCMD.ctrl;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            i = byHeader.Length;

            Array.Copy(data, 0, _byBuffer, i, data.Length);

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeResponseUnitPrice(byte[] data)
        {
            byte[] _byBuffer = new byte[nHeaderSize + data.Length + 2]; // 22
            byte byCmd = (byte)SNORECVCMD.unitprice;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            i = byHeader.Length;

            Array.Copy(data, 0, _byBuffer, i, data.Length);

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeResponseCurrent(byte[] data)
        {
            byte[] _byBuffer = new byte[nHeaderSize + 768 + 2]; // 22
            byte byCmd = (byte)SNORECVCMD.watt;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            i = byHeader.Length;

            byte[] temp = GetCurrentTable(data);

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        // complete
        public byte[] MakeResponseCurrentStatus()
        {
            byte[] _byBuffer = new byte[nHeaderSize + 132 + 2]; // 22
            byte byCmd = (byte)SNORECVCMD.status;
            byte byCtrl = (byte)CTRL.single;
            byte bySeq = 0;
            ushort uBufLen = (ushort)_byBuffer.Length;

            byte[] byHeader = MakeHeader(byCmd, uBufLen, bySeq, byCtrl);

            int i = 0;

            Array.Copy(byHeader, _byBuffer, byHeader.Length);

            i = nHeaderSize;

            byte[] temp = GetStatusToByte();

            Array.Copy(temp, 0, _byBuffer, i, temp.Length);

            //CRCCalculator crc = new CRCCalculator();
            ushort parity = CRCCalculator.MakeCRC(_byBuffer, _byBuffer.Length - 2);

#if BIGENDIAN
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
            parity = (ushort)(parity>>8);
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
#else
            _byBuffer[_byBuffer.Length - 2] = (byte)(parity & 0xFF);
            parity = (ushort)(parity >> 8);
            _byBuffer[_byBuffer.Length - 1] = (byte)(parity & 0xFF);
#endif

            return _byBuffer;
        }

        public byte[] MakeResponseHistory()
        {
            return null;
        }

        public byte[] GetCurrentTable(byte[] nday)
        {
            DateTime today = DateTime.Now;
            DateTime yesterday = today.AddDays(-1);
            uint[,] RemindCurrentTable = new uint[24, 4];

            byte[] _byBuffer = new byte[768];

            if (((int)nday[0] == (today.Year % 100)) && ((int)nday[1] == today.Month) && ((int)nday[2] == today.Day))
            {
                Array.Copy(RemindCurrentTableToday, RemindCurrentTable, RemindCurrentTable.Length);
            }
            else if (((int)nday[0] == (yesterday.Year % 100)) && ((int)nday[1] == yesterday.Month) && ((int)nday[2] == yesterday.Day))
            {
                Array.Copy(RemindCurrentTableYesterday, RemindCurrentTable, RemindCurrentTable.Length);
            }

            int idx = 0;
            int idx2 = RemindCurrentTable.Length * 4;
            try
            {

                for (int i = 0; i < 24; i++)
                {
                    for (int j = 0; j < 4; j++)
                    {
                        byte[] temp = BitConverter.GetBytes(RemindCurrentTable[i, j]);
                        byte[] temp2 = BitConverter.GetBytes(RemindCurrentCharging[i, j]);
                        _byBuffer[idx2++ ] = temp2[0];
                        _byBuffer[idx++] = temp[0];

                        _byBuffer[idx2++] = temp2[1];
                        _byBuffer[idx++] = temp[1];

                        _byBuffer[idx2++] = temp2[2];
                        _byBuffer[idx++] = temp[2];

                        _byBuffer[idx2++] = temp2[3];
                        _byBuffer[idx++] = temp[3];

                    }
                }
            }
            catch (Exception e)
            {
                System.Diagnostics.Debug.WriteLine(e.Message);
                System.Diagnostics.Debug.WriteLine(idx);
                System.Diagnostics.Debug.WriteLine(idx2);
            }

            return _byBuffer;
        }

        public byte[] GetStatusToByte()
        {
            byte[] _byBuffer = new byte[132];
            int i = 0;

            // 여기서 부터 데이터생성
            byte[] temp;
            // cpid
            temp = BitConverter.GetBytes((ushort)csos.Cpid);
            _byBuffer[i++] = temp[0];
            _byBuffer[i++] = temp[1];

            // 현재충전단가
            temp = BitConverter.GetBytes((ushort)(AVRIO.avrio.CurrentUnitPrice * (double)10));
            _byBuffer[i++] = temp[0];
            _byBuffer[i++] = temp[1];

            // 현재시간
            DateTime dt = DateTime.Now;
            _byBuffer[i++] = (byte)(dt.Year % 100);
            _byBuffer[i++] = (byte)dt.Month;
            _byBuffer[i++] = (byte)dt.Day;
            _byBuffer[i++] = (byte)dt.Hour;
            _byBuffer[i++] = (byte)dt.Minute;
            _byBuffer[i++] = (byte)dt.Second;
            _byBuffer[i++] = 0;
            _byBuffer[i++] = 0;

            // 충전기 상태
            _byBuffer[i++] = GetCurrentStatus();
            // reserved
            _byBuffer[i++] = 0;

            // 결제방법
            _byBuffer[i++] = (byte)AVRIO.avrio.BillMethod;

            // 충전모드
            _byBuffer[i++] = (byte)AVRIO.avrio.ChargeMode;

            // fault 10 bytes
            byte[] fault = new byte[10];
            if (AVRIO.avrio.FaultType != FaultType.None)
            {
                fault[(int)AVRIO.avrio.FaultType - 1] = 1;
            }
            foreach (byte b in fault)
            {
                _byBuffer[i++] = b;
            }

            // reserved
            _byBuffer[i++] = 0;

            // 충전요구방법 (완속은 SOC만 지원)
            if (AVRIO.avrio.DevType == 1)
            {
                _byBuffer[i++] = 1;
            }
            else
            {
                _byBuffer[i++] = (byte)((byte)AVRIO.avrio.ChargeMode + (byte)1);
            }

            // 회원카드번호
            temp = Encoding.ASCII.GetBytes(AVRIO.avrio.CardNo);
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }
            if (temp.Length < 16)
            {
                i += 16 - temp.Length;
            }

            // 차량정보
            i += 16;

            // 충전요구량
            if (AVRIO.avrio.ChargeMode == 1)
            {
                temp = BitConverter.GetBytes((uint)(AVRIO.avrio.ChargeValue * 1000));
                foreach (byte b in temp)
                {
                    _byBuffer[i++] = b;
                }
            }
            else
            {
                i += 4;
            }

            // 충전요구금액
            if (AVRIO.avrio.ChargeMode == 2)
            {
                temp = BitConverter.GetBytes((uint)(AVRIO.avrio.ChargeValue));
                foreach (byte b in temp)
                {
                    _byBuffer[i++] = b;
                }
            }
            else
            {
                i += 4;
            }

            // 충전시작일시
            dt = AVRIO.avrio.ChargeStartTime;
            _byBuffer[i++] = (byte)(dt.Year % 100);
            _byBuffer[i++] = (byte)dt.Month;
            _byBuffer[i++] = (byte)dt.Day;
            _byBuffer[i++] = (byte)dt.Hour;
            _byBuffer[i++] = (byte)dt.Minute;
            _byBuffer[i++] = (byte)dt.Second;
            _byBuffer[i++] = 0;
            _byBuffer[i++] = 0;
            // 충전종료일시
            if (AVRIO.avrio.CurrentStatus == SysStatus.SysRun)
            {
                dt = DateTime.Now.AddMinutes(AVRIO.avrio.ChargeRemainTime);
            }
            else
            {
                dt = AVRIO.avrio.ChargeEndTime;
            }
            _byBuffer[i++] = (byte)(dt.Year % 100);
            _byBuffer[i++] = (byte)dt.Month;
            _byBuffer[i++] = (byte)dt.Day;
            _byBuffer[i++] = (byte)dt.Hour;
            _byBuffer[i++] = (byte)dt.Minute;
            _byBuffer[i++] = (byte)dt.Second;
            _byBuffer[i++] = 0;
            _byBuffer[i++] = 0;

            // 충전량
            temp = BitConverter.GetBytes((uint)(AVRIO.avrio.ChargeWatt * 1000));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 충전누적시간
            TimeSpan t = new TimeSpan();
            if (AVRIO.avrio.CurrentStatus == SysStatus.SysFinish || AVRIO.avrio.CurrentStatus == SysStatus.SysPayCheck || AVRIO.avrio.CurrentStatus == SysStatus.SysConnectionEject)
            {
                t = AVRIO.avrio.ChargeEndTime.Subtract(AVRIO.avrio.ChargeStartTime);
            }
            else if (AVRIO.avrio.CurrentStatus == SysStatus.SysRun)
            {
                t = DateTime.Now.Subtract(AVRIO.avrio.ChargeStartTime);
            }
            temp = BitConverter.GetBytes((uint)(t.TotalSeconds));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 충전입력전압
            i += 4;

            // 충전입력전류
            i += 4;

            // 충전 출력 전압
            temp = BitConverter.GetBytes((uint)(AVRIO.avrio.BmsInfo.OutVolt * 10));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 충전 출력 전류
            temp = BitConverter.GetBytes((uint)(AVRIO.avrio.BmsInfo.OutCurrent * 10));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 충전 요금
            temp = BitConverter.GetBytes((uint)(AVRIO.avrio.ChargePrice));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 배터리 soc
            temp = BitConverter.GetBytes((uint)(AVRIO.avrio.ChargeSOC));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 배터리 잔량
            temp = BitConverter.GetBytes((float)(AVRIO.avrio.ChargeSOC));
            foreach (byte b in temp)
            {
                _byBuffer[i++] = b;
            }

            // 배터리 전압
            i += 4;

            // 배터리 전류
            i += 4;

            // 배터리 온도
            i += 4;

            return _byBuffer;
        }

        public byte GetCurrentStatus()
        {
            byte ret = 0;

            switch (AVRIO.avrio.CurrentStatus)
            {
                case SysStatus.SysStandby:
                    ret = 11;
                    break;
                case SysStatus.SysReady:
                    ret = 12;
                    break;
                case SysStatus.SysConectionFinish:
                    ret = 14;
                    break;
                case SysStatus.SysRun:
                    ret = 15;
                    break;
                case SysStatus.SysConnectionEject:
                    ret = 16;
                    break;
                case SysStatus.SysPayCheck:
                    ret = 17;
                    break;
                default:
                    ret = 11;
                    break;
            }

            return ret;
        }

        #region 변환함수

        /// <summary> Convert a string of hex digits (ex: E4 CA B2) to a byte array. </summary>
        /// <param name="s"> The string containing the hex digits (with or without spaces). </param>
        /// <returns> Returns an array of bytes. </returns>
        public byte[] HexStringToByteArray(string s)
        {
            s = s.Replace(" ", "");
            byte[] buffer = new byte[s.Length / 2];
            for (int i = 0; i < s.Length; i += 2)
                buffer[i / 2] = (byte)Convert.ToByte(s.Substring(i, 2), 16);
            return buffer;
        }

        /// <summary> Converts an array of bytes into a formatted string of hex digits (ex: E4 CA B2)</summary>
        /// <param name="data"> The array of bytes to be translated into a string of hex digits. </param>
        /// <returns> Returns a well formatted string of hex digits with spacing. </returns>
        public string ByteArrayToHexString(byte[] data)
        {
            StringBuilder sb = new StringBuilder(data.Length * 3);
            foreach (byte b in data)
                sb.Append(Convert.ToString(b, 16).PadLeft(2, '0').PadRight(3, ' '));

            return sb.ToString().ToUpper();
        }
        #endregion
    }

    public class CRCCalculator
    {
        // CRC16 is based on the polynomial x^16+x^15+x^2+1 (Hex : 0x8005)   
        private static UInt16[] CRC16Table = new UInt16[] {   
                0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,   
                0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,   
                0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,   
                0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,   
                0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,   
                0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,   
                0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,   
                0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,   
                0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,   
                0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,   
                0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,   
                0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,   
                0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,   
                0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,   
                0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,   
                0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,   
                0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,   
                0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,   
                0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,   
                0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,   
                0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,   
                0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,   
                0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,   
                0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,   
                0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,   
                0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,   
                0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,   
                0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,   
                0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,   
                0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,   
                0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,   
                0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040,   
            };


        private static byte[] auchCRCHiTemp = new byte[] {
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
		0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
		0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
		0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
		0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
		0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
		0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
	};

        private static byte[] auchCRCLoTemp = new byte[]  {
		0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
		0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
		0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
		0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
		0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
		0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
		0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
		0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
		0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
		0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
		0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
		0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
		0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
		0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
		0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
		0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
		0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
		0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
		0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
		0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
		0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
		0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
		0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
		0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
		0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};

        public static UInt16 CRC16IBM(byte[] _byBuffer, int length)
        {
            uint uiCRC = 0;

            //foreach (byte byBuffer in _byBuffer)
            for (int i = 0; i < length; i++)
            {
                uiCRC = (uiCRC >> 8) ^ CRC16Table[(uiCRC ^ _byBuffer[i]) & 0xFF];
            }
            return (UInt16)uiCRC;
        }

        public static UInt16 MakeCRC(byte[] _byBuffer, int length)
        {
            byte uchCRCHi = 0xFF;
            byte uchCRCLo = 0xFF;
            byte uIndex;

            // 다회로 차단기의 소스를 참고 하였다.
            // 그런데 이는 MODBUS.ORG의 샘플 소스의 내용과 다르다. hyung
            for (int i = 0; i < length; i++)
            {
                uIndex = (byte)(uchCRCHi ^ _byBuffer[i]);
                uchCRCHi = (byte)(uchCRCLo ^ auchCRCHiTemp[uIndex]);
                uchCRCLo = auchCRCLoTemp[uIndex];
            }
            return (UInt16)(uchCRCHi << 8 | uchCRCLo);
        }

    }
}
